<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang xml:lang>
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="mpark/wg21" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <meta name="dcterms.date" content="2019-09-28" />
  <title>Accessing Object Representations</title>
  <style>
      code{white-space: pre-wrap;}
      span.smallcaps{font-variant: small-caps;}
      span.underline{text-decoration: underline;}
      div.column{display: inline-block; vertical-align: top; width: 50%;}
  </style>
  <style>
code.sourceCode > span { display: inline-block; line-height: 1.25; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode { white-space: pre; position: relative; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
code.sourceCode { white-space: pre-wrap; }
code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
    color: #aaaaaa;
  }
pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
div.sourceCode
  {  background-color: #f6f8fa; }
@media screen {
code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
code span. { } /* Normal */
code span.al { color: #ff0000; } /* Alert */
code span.an { } /* Annotation */
code span.at { } /* Attribute */
code span.bn { color: #9f6807; } /* BaseN */
code span.bu { color: #9f6807; } /* BuiltIn */
code span.cf { color: #00607c; } /* ControlFlow */
code span.ch { color: #9f6807; } /* Char */
code span.cn { } /* Constant */
code span.co { color: #008000; font-style: italic; } /* Comment */
code span.cv { color: #008000; font-style: italic; } /* CommentVar */
code span.do { color: #008000; } /* Documentation */
code span.dt { color: #00607c; } /* DataType */
code span.dv { color: #9f6807; } /* DecVal */
code span.er { color: #ff0000; font-weight: bold; } /* Error */
code span.ex { } /* Extension */
code span.fl { color: #9f6807; } /* Float */
code span.fu { } /* Function */
code span.im { } /* Import */
code span.in { color: #008000; } /* Information */
code span.kw { color: #00607c; } /* Keyword */
code span.op { color: #af1915; } /* Operator */
code span.ot { } /* Other */
code span.pp { color: #6f4e37; } /* Preprocessor */
code span.re { } /* RegionMarker */
code span.sc { color: #9f6807; } /* SpecialChar */
code span.ss { color: #9f6807; } /* SpecialString */
code span.st { color: #9f6807; } /* String */
code span.va { } /* Variable */
code span.vs { color: #9f6807; } /* VerbatimString */
code span.wa { color: #008000; font-weight: bold; } /* Warning */
code.diff {color: #898887}
code.diff span.va {color: #006e28}
code.diff span.st {color: #bf0303}
  </style>
  <style type="text/css">
body {
margin: 5em;
font-family: serif;

hyphens: auto;
line-height: 1.35;
}
div.wrapper {
max-width: 60em;
margin: auto;
}
ul {
list-style-type: none;
padding-left: 2em;
margin-top: -0.2em;
margin-bottom: -0.2em;
}
a {
text-decoration: none;
color: #4183C4;
}
a.hidden_link {
text-decoration: none;
color: inherit;
}
li {
margin-top: 0.6em;
margin-bottom: 0.6em;
}
h1, h2, h3, h4 {
position: relative;
line-height: 1;
}
a.self-link {
position: absolute;
top: 0;
left: calc(-1 * (3.5rem - 26px));
width: calc(3.5rem - 26px);
height: 2em;
text-align: center;
border: none;
transition: opacity .2s;
opacity: .5;
font-family: sans-serif;
font-weight: normal;
font-size: 83%;
}
a.self-link:hover { opacity: 1; }
a.self-link::before { content: "§"; }
ul > li:before {
content: "\2014";
position: absolute;
margin-left: -1.5em;
}
:target { background-color: #C9FBC9; }
:target .codeblock { background-color: #C9FBC9; }
:target ul { background-color: #C9FBC9; }
.abbr_ref { float: right; }
.folded_abbr_ref { float: right; }
:target .folded_abbr_ref { display: none; }
:target .unfolded_abbr_ref { float: right; display: inherit; }
.unfolded_abbr_ref { display: none; }
.secnum { display: inline-block; min-width: 35pt; }
.header-section-number { display: inline-block; min-width: 35pt; }
.annexnum { display: block; }
div.sourceLinkParent {
float: right;
}
a.sourceLink {
position: absolute;
opacity: 0;
margin-left: 10pt;
}
a.sourceLink:hover {
opacity: 1;
}
a.itemDeclLink {
position: absolute;
font-size: 75%;
text-align: right;
width: 5em;
opacity: 0;
}
a.itemDeclLink:hover { opacity: 1; }
span.marginalizedparent {
position: relative;
left: -5em;
}
li span.marginalizedparent { left: -7em; }
li ul > li span.marginalizedparent { left: -9em; }
li ul > li ul > li span.marginalizedparent { left: -11em; }
li ul > li ul > li ul > li span.marginalizedparent { left: -13em; }
div.footnoteNumberParent {
position: relative;
left: -4.7em;
}
a.marginalized {
position: absolute;
font-size: 75%;
text-align: right;
width: 5em;
}
a.enumerated_item_num {
position: relative;
left: -3.5em;
display: inline-block;
margin-right: -3em;
text-align: right;
width: 3em;
}
div.para { margin-bottom: 0.6em; margin-top: 0.6em; text-align: justify; }
div.section { text-align: justify; }
div.sentence { display: inline; }
span.indexparent {
display: inline;
position: relative;
float: right;
right: -1em;
}
a.index {
position: absolute;
display: none;
}
a.index:before { content: "⟵"; }

a.index:target {
display: inline;
}
.indexitems {
margin-left: 2em;
text-indent: -2em;
}
div.itemdescr {
margin-left: 3em;
}
.bnf {
font-family: serif;
margin-left: 40pt;
margin-top: 0.5em;
margin-bottom: 0.5em;
}
.ncbnf {
font-family: serif;
margin-top: 0.5em;
margin-bottom: 0.5em;
margin-left: 40pt;
}
.ncsimplebnf {
font-family: serif;
font-style: italic;
margin-top: 0.5em;
margin-bottom: 0.5em;
margin-left: 40pt;
background: inherit; 
}
span.textnormal {
font-style: normal;
font-family: serif;
white-space: normal;
display: inline-block;
}
span.rlap {
display: inline-block;
width: 0px;
}
span.descr { font-style: normal; font-family: serif; }
span.grammarterm { font-style: italic; }
span.term { font-style: italic; }
span.terminal { font-family: monospace; font-style: normal; }
span.nonterminal { font-style: italic; }
span.tcode { font-family: monospace; font-style: normal; }
span.textbf { font-weight: bold; }
span.textsc { font-variant: small-caps; }
a.nontermdef { font-style: italic; font-family: serif; }
span.emph { font-style: italic; }
span.techterm { font-style: italic; }
span.mathit { font-style: italic; }
span.mathsf { font-family: sans-serif; }
span.mathrm { font-family: serif; font-style: normal; }
span.textrm { font-family: serif; }
span.textsl { font-style: italic; }
span.mathtt { font-family: monospace; font-style: normal; }
span.mbox { font-family: serif; font-style: normal; }
span.ungap { display: inline-block; width: 2pt; }
span.textit { font-style: italic; }
span.texttt { font-family: monospace; }
span.tcode_in_codeblock { font-family: monospace; font-style: normal; }
span.phantom { color: white; }

span.math { font-style: normal; }
span.mathblock {
display: block;
margin-left: auto;
margin-right: auto;
margin-top: 1.2em;
margin-bottom: 1.2em;
text-align: center;
}
span.mathalpha {
font-style: italic;
}
span.synopsis {
font-weight: bold;
margin-top: 0.5em;
display: block;
}
span.definition {
font-weight: bold;
display: block;
}
.codeblock {
margin-left: 1.2em;
line-height: 127%;
}
.outputblock {
margin-left: 1.2em;
line-height: 127%;
}
div.itemdecl {
margin-top: 2ex;
}
code.itemdeclcode {
white-space: pre;
display: block;
}
span.textsuperscript {
vertical-align: super;
font-size: smaller;
line-height: 0;
}
.footnotenum { vertical-align: super; font-size: smaller; line-height: 0; }
.footnote {
font-size: small;
margin-left: 2em;
margin-right: 2em;
margin-top: 0.6em;
margin-bottom: 0.6em;
}
div.minipage {
display: inline-block;
margin-right: 3em;
}
div.numberedTable {
text-align: center;
margin: 2em;
}
div.figure {
text-align: center;
margin: 2em;
}
table {
border: 1px solid black;
border-collapse: collapse;
margin-left: auto;
margin-right: auto;
margin-top: 0.8em;
text-align: left;
hyphens: none; 
}
td, th {
padding-left: 1em;
padding-right: 1em;
vertical-align: top;
}
td.empty {
padding: 0px;
padding-left: 1px;
}
td.left {
text-align: left;
}
td.right {
text-align: right;
}
td.center {
text-align: center;
}
td.justify {
text-align: justify;
}
td.border {
border-left: 1px solid black;
}
tr.rowsep, td.cline {
border-top: 1px solid black;
}
tr.even, tr.odd {
border-bottom: 1px solid black;
}
tr.capsep {
border-top: 3px solid black;
border-top-style: double;
}
tr.header {
border-bottom: 3px solid black;
border-bottom-style: double;
}
th {
border-bottom: 1px solid black;
}
span.centry {
font-weight: bold;
}
div.table {
display: block;
margin-left: auto;
margin-right: auto;
text-align: center;
width: 90%;
}
span.indented {
display: block;
margin-left: 2em;
margin-bottom: 1em;
margin-top: 1em;
}
ol.enumeratea { list-style-type: none; background: inherit; }
ol.enumerate { list-style-type: none; background: inherit; }

code.sourceCode > span { display: inline; }

div#refs p { padding-left: 32px; text-indent: -32px; }
</style>
  <link href="data:image/vnd.microsoft.icon;base64,AAABAAIAEBAAAAEAIABoBAAAJgAAACAgAAABACAAqBAAAI4EAAAoAAAAEAAAACAAAAABACAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA////AIJEAACCRAAAgkQAAIJEAACCRAAAgkQAVoJEAN6CRADegkQAWIJEAACCRAAAgkQAAIJEAACCRAAA////AP///wCCRAAAgkQAAIJEAACCRAAsgkQAvoJEAP+CRAD/gkQA/4JEAP+CRADAgkQALoJEAACCRAAAgkQAAP///wD///8AgkQAAIJEABSCRACSgkQA/IJEAP99PQD/dzMA/3czAP99PQD/gkQA/4JEAPyCRACUgkQAFIJEAAD///8A////AHw+AFiBQwDqgkQA/4BBAP9/PxP/uZd6/9rJtf/bybX/upd7/39AFP+AQQD/gkQA/4FDAOqAQgBc////AP///wDKklv4jlEa/3o7AP+PWC//8+3o///////////////////////z7un/kFox/35AAP+GRwD/mVYA+v///wD///8A0Zpk+NmibP+0d0T/8evj///////+/fv/1sKz/9bCs//9/fr//////+/m2/+NRwL/nloA/5xYAPj///8A////ANKaZPjRmGH/5cKh////////////k149/3UwAP91MQD/lmQ//86rhv+USg3/m1YA/5hSAP+bVgD4////AP///wDSmmT4zpJY/+/bx///////8+TV/8mLT/+TVx//gkIA/5lVAP+VTAD/x6B//7aEVv/JpH7/s39J+P///wD///8A0ppk+M6SWP/u2sf///////Pj1f/Nj1T/2KFs/8mOUv+eWhD/lEsA/8aee/+0glT/x6F7/7J8Rvj///8A////ANKaZPjRmGH/48Cf///////+/v7/2qt//82PVP/OkFX/37KJ/86siv+USg7/mVQA/5hRAP+bVgD4////AP///wDSmmT40ppk/9CVXP/69O////////7+/v/x4M//8d/P//7+/f//////9u7n/6tnJf+XUgD/nFgA+P///wD///8A0ppk+NKaZP/RmWL/1qNy//r07///////////////////////+vXw/9akdP/Wnmn/y5FY/6JfFvj///8A////ANKaZFTSmmTo0ppk/9GYYv/Ql1//5cWm//Hg0P/x4ND/5cWm/9GXYP/RmGH/0ppk/9KaZOjVnmpY////AP///wDSmmQA0ppkEtKaZI7SmmT60ppk/9CWX//OkVb/zpFW/9CWX//SmmT/0ppk/NKaZJDSmmQS0ppkAP///wD///8A0ppkANKaZADSmmQA0ppkKtKaZLrSmmT/0ppk/9KaZP/SmmT/0ppkvNKaZCrSmmQA0ppkANKaZAD///8A////ANKaZADSmmQA0ppkANKaZADSmmQA0ppkUtKaZNzSmmTc0ppkVNKaZADSmmQA0ppkANKaZADSmmQA////AP5/AAD4HwAA4AcAAMADAACAAQAAgAEAAIABAACAAQAAgAEAAIABAACAAQAAgAEAAMADAADgBwAA+B8AAP5/AAAoAAAAIAAAAEAAAAABACAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA////AP///wCCRAAAgkQAAIJEAACCRAAAgkQAAIJEAACCRAAAgkQAAIJEAACCRAAAgkQAAIJEAAyCRACMgkQA6oJEAOqCRACQgkQAEIJEAACCRAAAgkQAAIJEAACCRAAAgkQAAIJEAACCRAAAgkQAAIJEAACCRAAA////AP///wD///8A////AIJEAACCRAAAgkQAAIJEAACCRAAAgkQAAIJEAACCRAAAgkQAAIJEAACCRABigkQA5oJEAP+CRAD/gkQA/4JEAP+CRADqgkQAZoJEAACCRAAAgkQAAIJEAACCRAAAgkQAAIJEAACCRAAAgkQAAIJEAAD///8A////AP///wD///8AgkQAAIJEAACCRAAAgkQAAIJEAACCRAAAgkQAAIJEAACCRAA4gkQAwoJEAP+CRAD/gkQA/4JEAP+CRAD/gkQA/4JEAP+CRAD/gkQAxIJEADyCRAAAgkQAAIJEAACCRAAAgkQAAIJEAACCRAAAgkQAAP///wD///8A////AP///wCCRAAAgkQAAIJEAACCRAAAgkQAAIJEAACCRAAWgkQAmIJEAP+CRAD/gkQA/4JEAP+CRAD/gkQA/4JEAP+CRAD/gkQA/4JEAP+CRAD/gkQA/4JEAJyCRAAYgkQAAIJEAACCRAAAgkQAAIJEAACCRAAA////AP///wD///8A////AIJEAACCRAAAgkQAAIJEAACCRAAAgkQAdIJEAPCCRAD/gkQA/4JEAP+CRAD/gkQA/4JEAP+CRAD/gkQA/4JEAP+CRAD/gkQA/4JEAP+CRAD/gkQA/4JEAPSCRAB4gkQAAIJEAACCRAAAgkQAAIJEAAD///8A////AP///wD///8AgkQAAIJEAACCRAAAgkQASoJEANKCRAD/gkQA/4JEAP+CRAD/g0YA/39AAP9zLgD/bSQA/2shAP9rIQD/bSQA/3MuAP9/PwD/g0YA/4JEAP+CRAD/gkQA/4JEAP+CRADUgkQAToJEAACCRAAAgkQAAP///wD///8A////AP///wB+PwAAgkUAIoJEAKiCRAD/gkQA/4JEAP+CRAD/hEcA/4BBAP9sIwD/dTAA/5RfKv+viF7/vp56/76ee/+wiF7/lWAr/3YxAP9sIwD/f0AA/4RHAP+CRAD/gkQA/4JEAP+CRAD/gkQArIJEACaBQwAA////AP///wD///8A////AIBCAEBzNAD6f0EA/4NFAP+CRAD/gkQA/4VIAP92MwD/bSUA/6N1Tv/ezsL/////////////////////////////////38/D/6V3Uv9uJgD/dTEA/4VJAP+CRAD/gkQA/4JEAP+BQwD/fUAA/4FDAEj///8A////AP///wD///8AzJRd5qBlKf91NgD/dDUA/4JEAP+FSQD/cy4A/3YyAP/PuKP//////////////////////////////////////////////////////9K7qP94NQD/ciwA/4VJAP+CRAD/fkEA/35BAP+LSwD/mlYA6v///wD///8A////AP///wDdpnL/4qx3/8KJUv+PUhf/cTMA/3AsAP90LgD/4dK+/////////////////////////////////////////////////////////////////+TYxf91MAD/dTIA/31CAP+GRwD/llQA/6FcAP+gWwD8////AP///wD///8A////ANGZY/LSm2X/4ap3/92mcP+wdT3/byQA/8mwj////////////////////////////////////////////////////////////////////////////+LYxv9zLgP/jUoA/59bAP+hXAD/nFgA/5xYAPL///8A////AP///wD///8A0ppk8tKaZP/RmWL/1p9q/9ubXv/XqXj////////////////////////////7+fD/vZyG/6BxS/+gcUr/vJuE//r37f//////////////////////3MOr/5dQBf+dVQD/nVkA/5xYAP+cWAD/nFgA8v///wD///8A////AP///wDSmmTy0ppk/9KaZP/SmWP/yohJ//jo2P//////////////////////4NTG/4JDFf9lGAD/bSQA/20kAP9kGAD/fz8S/+Xb0f//////5NG9/6txN/+LOgD/m1QA/51aAP+cWAD/m1cA/5xYAP+cWADy////AP///wD///8A////ANKaZPLSmmT/0ppk/8+TWf/Unmv//v37//////////////////////+TWRr/VwsA/35AAP+ERgD/g0UA/4JGAP9lHgD/kFga/8KXX/+TRwD/jT4A/49CAP+VTQD/n10A/5xYAP+OQQD/lk4A/55cAPL///8A////AP///wD///8A0ppk8tKaZP/SmmT/y4tO/92yiP//////////////////////8NnE/8eCQP+rcTT/ez0A/3IyAP98PgD/gEMA/5FSAP+USwD/jj8A/5lUAP+JNwD/yqV2/694Mf+HNQD/jkAA/82rf/+laBj/jT4A8v///wD///8A////AP///wDSmmTy0ppk/9KaZP/LiUr/4byY///////////////////////gupX/0I5P/+Wuev/Lklz/l1sj/308AP+QSwD/ol0A/59aAP+aVQD/k0oA/8yoh///////+fXv/6pwO//Lp3v///////Pr4f+oay7y////AP///wD///8A////ANKaZPLSmmT/0ppk/8uJSv/hvJj//////////////////////+G7l//Jhkb/0ppk/96nc//fqXX/x4xO/6dkFP+QSQD/llEA/5xXAP+USgD/yaOA///////38uv/qG05/8ijdv//////8efb/6ZpLPL///8A////AP///wD///8A0ppk8tKaZP/SmmT/zIxO/9yxh///////////////////////7dbA/8iEQf/Sm2X/0Zlj/9ScZv/eqHf/2KJv/7yAQf+XTgD/iToA/5lSAP+JNgD/yKFv/611LP+HNQD/jT8A/8qmeP+kZRT/jT4A8v///wD///8A////AP///wDSmmTy0ppk/9KaZP/Pk1n/1J5q//78+//////////////////+/fv/1aFv/8iEQv/Tm2b/0ppl/9GZY//Wn2z/1pZc/9eldf/Bl2b/kUcA/4w9AP+OQAD/lUwA/59eAP+cWQD/jT8A/5ZOAP+eXADy////AP///wD///8A////ANKaZPLSmmT/0ppk/9KZY//KiEn/8d/P///////////////////////47+f/05tm/8iCP//KiEj/yohJ/8eCP//RmGH//vfy///////n1sP/rXQ7/4k4AP+TTAD/nVoA/5xYAP+cVwD/nFgA/5xYAPL///8A////AP///wD///8A0ppk8tKaZP/SmmT/0ptl/8uLTf/aq37////////////////////////////+/fz/6c2y/961jv/etY7/6Myx//78+v//////////////////////3MWv/5xXD/+ORAD/mFQA/51ZAP+cWAD/nFgA8v///wD///8A////AP///wDSmmTy0ppk/9KaZP/SmmT/0ppk/8mFRP/s1b//////////////////////////////////////////////////////////////////////////////+PD/0JFU/7NzMv+WUQD/kUsA/5tXAP+dWQDy////AP///wD///8A////ANKaZP/SmmT/0ppk/9KaZP/Sm2X/z5NZ/8yMT//z5NX/////////////////////////////////////////////////////////////////9Ofa/8yNUP/UmGH/36p5/8yTWv+qaSD/kksA/5ROAPz///8A////AP///wD///8A0ppk5NKaZP/SmmT/0ppk/9KaZP/TnGf/zY9T/82OUv/t1sD//////////////////////////////////////////////////////+7Yw//OkFX/zI5R/9OcZ//SmmP/26V0/9ymdf/BhUf/ol8R6P///wD///8A////AP///wDSmmQ80ppk9tKaZP/SmmT/0ppk/9KaZP/TnGj/zpFW/8qJSv/dson/8uHS//////////////////////////////////Lj0//etIv/y4lL/86QVf/TnGj/0ppk/9KaZP/RmWP/05xn/9ymdfjUnWdC////AP///wD///8A////ANKaZADSmmQc0ppkotKaZP/SmmT/0ppk/9KaZP/Tm2b/0Zli/8qJSf/NjlH/16Z3/+G8mP/myKr/5siq/+G8mP/Xp3f/zY5S/8qISf/RmGH/05tm/9KaZP/SmmT/0ppk/9KaZP/SmmSm0pljINWdaQD///8A////AP///wD///8A0ppkANKaZADSmmQA0ppkQtKaZMrSmmT/0ppk/9KaZP/SmmT/0ptl/9GYYf/Nj1P/y4lL/8qISP/KiEj/y4lK/82PU//RmGH/0ptl/9KaZP/SmmT/0ppk/9KaZP/SmmTO0ppkRtKaZADSmmQA0ppkAP///wD///8A////AP///wDSmmQA0ppkANKaZADSmmQA0ppkANKaZGzSmmTu0ppk/9KaZP/SmmT/0ppk/9KaZP/SmmT/0ppk/9KaZP/SmmT/0ppk/9KaZP/SmmT/0ppk/9KaZP/SmmTw0ppkcNKaZADSmmQA0ppkANKaZADSmmQA////AP///wD///8A////ANKaZADSmmQA0ppkANKaZADSmmQA0ppkANKaZBLSmmSQ0ppk/9KaZP/SmmT/0ppk/9KaZP/SmmT/0ppk/9KaZP/SmmT/0ppk/9KaZP/SmmT/0ppklNKaZBTSmmQA0ppkANKaZADSmmQA0ppkANKaZAD///8A////AP///wD///8A0ppkANKaZADSmmQA0ppkANKaZADSmmQA0ppkANKaZADSmmQy0ppkutKaZP/SmmT/0ppk/9KaZP/SmmT/0ppk/9KaZP/SmmT/0ppkvtKaZDbSmmQA0ppkANKaZADSmmQA0ppkANKaZADSmmQA0ppkAP///wD///8A////AP///wDSmmQA0ppkANKaZADSmmQA0ppkANKaZADSmmQA0ppkANKaZADSmmQA0ppkXNKaZODSmmT/0ppk/9KaZP/SmmT/0ppk5NKaZGDSmmQA0ppkANKaZADSmmQA0ppkANKaZADSmmQA0ppkANKaZADSmmQA////AP///wD///8A////ANKaZADSmmQA0ppkANKaZADSmmQA0ppkANKaZADSmmQA0ppkANKaZADSmmQA0ppkBtKaZIbSmmTo0ppk6tKaZIrSmmQK0ppkANKaZADSmmQA0ppkANKaZADSmmQA0ppkANKaZADSmmQA0ppkANKaZAD///8A////AP/8P///+B///+AH//+AAf//AAD//AAAP/AAAA/gAAAHwAAAA8AAAAPAAAADwAAAA8AAAAPAAAADwAAAA8AAAAPAAAADwAAAA8AAAAPAAAADwAAAA8AAAAPAAAADwAAAA+AAAAfwAAAP/AAAP/8AAP//gAH//+AH///4H////D//" rel="icon" />
  <!--[if lt IE 9]>
    <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.3/html5shiv-printshiv.min.js"></script>
  <![endif]-->
  
</head>
<body>
<div class="wrapper">
<header id="title-block-header">
<h1 class="title" style="text-align:center">Accessing Object Representations</h1>

<table style="border:none;float:right">
  <tr>
    <td>Document #: </td>
    <td>P1839R1</td>
  </tr>
  <tr>
    <td>Date: </td>
    <td>2019-09-28</td>
  </tr>
  <tr>
    <td style="vertical-align:top">Project: </td>
    <td>Programming Language C++<br>
      Core Working Group<br>
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top">Reply-to: </td>
    <td>
      Krystian Stasiowski<br>&lt;<a href="mailto:sdkrystian@gmail.com" class="email">sdkrystian@gmail.com</a>&gt;<br>
    </td>
  </tr>
</table>

</header>
<div style="clear:both">
<h1 id="abstract"><span class="header-section-number">1</span> Abstract<a href="#abstract" class="self-link"></a></h1>
<p>Allow access to the object representation of an object.</p>
<h1 id="revisions"><span class="header-section-number">2</span> Revisions<a href="#revisions" class="self-link"></a></h1>
<h2 id="changes-since-p1839r0"><span class="header-section-number">2.1</span> Changes since [P1839R0]<a href="#changes-since-p1839r0" class="self-link"></a></h2>
<ul>
<li><p>Allow pointer arithmetic on expressions of type <code>unsigned char*</code>, <code>char*</code> and <code>std::byte*</code> when pointing to objects of different type.</p></li>
<li><p>Removed exclusion of the object representation of objects of zero size from appearing in the object representation of their containing object.</p></li>
<li><p>Added multi-dimensional arrays of contiguous-layout types to the definition of contiguous-layout types.</p></li>
<li><p>Slight change to the behavior of <code>std::launder</code> for when there are multiple viable objects.</p></li>
</ul>
<h1 id="motivation"><span class="header-section-number">3</span> Motivation<a href="#motivation" class="self-link"></a></h1>
<p>This proposal does not intend to introduce anything new, but rather to standardize a common existing practice. Accessing the underlying bytes of an object has been a long-standing practice in C and C++ alike, but in C++, doing so is typically undefined behavior. With current wording, it is impossible to obtain a pointer to an element of the object representation, with an expression such as <code>reinterpret_cast&lt;char*&gt;(&amp;a)</code> typically yielding a pointer to the original object, with only the type of the expression being changed. This does not represent the intent of CWG, as exemplified by <span class="citation" data-cites="CWG1314">[<a href="#ref-CWG1314" role="doc-biblioref">CWG1314</a>]</span> in which it is stated that access to the object representation is intended to be well defined.</p>
<p>This has only recently become undefined behavior as of C++17, when <span class="citation" data-cites="P0137R1">[<a href="#ref-P0137R1" role="doc-biblioref">P0137R1</a>]</span> was accepted. This proposal includes a change to how pointers work, notably that they point to objects, rather than just representing an address, and it seems that the proposal neglected to add any provisions to allow access to the object representation of an object.</p>
<h1 id="problem"><span class="header-section-number">4</span> Problem<a href="#problem" class="self-link"></a></h1>
<p>This issue exists due to two primary reasons: casting and pointer arithmetic. Given the following code:</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb1-1"><a href="#cb1-1"></a><span class="dt">int</span> a <span class="op">=</span> <span class="dv">420</span>;</span>
<span id="cb1-2"><a href="#cb1-2"></a><span class="dt">char</span> b <span class="op">=</span> <span class="op">*</span><span class="kw">reinterpret_cast</span><span class="op">&lt;</span><span class="dt">char</span><span class="op">*&gt;(&amp;</span>a<span class="op">)</span>;</span></code></pre></div>

<p>There exist no provisions in the current wording for the pointer to bind to any <code>char</code> object, or element of the object representation. This particular <code>reinterpret_cast</code> is exactly equivalent to <code>static_cast&lt;char*&gt;(static_cast&lt;void*&gt;(&amp;a))</code> as per <a href="http://eel.is/c++draft/expr.reinterpret.cast#7">[expr.reinterpret.cast] p7</a> and as such, <a href="http://eel.is/c++draft/expr.static.cast#13">[expr.static.cast] p13</a> dictates that the value of the pointer be unchanged, leaving it pointing to the original object. When the lvalue-to-rvalue conversion is applied to the initializer expression when initializing <code>b</code>, the behavior is undefined as per <a href="http://eel.is/c++draft/expr.pre#4">[expr.pre] p4</a> because the result of such a conversion would be the value of the <code>int</code> object (<code>420</code>), which is not a value representable by <code>char</code>.</p>
<p>Additionally, if such wording did exist, an object representation as defined by <a href="http://eel.is/c++draft/basic.types#4">[basic.types] p4</a> is a sequence of <code>unsigned char</code> objects, not an array, and is unsuitable for pointer arithmetic given the current object model.</p>
<h1 id="changes"><span class="header-section-number">5</span> Changes<a href="#changes" class="self-link"></a></h1>
<ul>
<li><p>Introduce contiguous-layout types, a classification of types that encompass scalar types, and class types without virtual functions or virtual bases and no subobjects of non-contiguous-layout class type or arrays of such types.</p></li>
<li><p>Specify that contiguous-layout types are guaranteed to be contiguous.</p></li>
<li><p>Change object representations to be considered an array if the type of the object they represent is a contiguous-layout type.</p>
<ul>
<li><p>Objects of type <code>unsigned char</code>, <code>char</code> and <code>std::byte</code> and arrays of such types suffice as being their own object representation to prevent an infinitely recurring property.</p></li>
<li><p>The value of the elements of an object representation of a type other than <code>unsigned char</code>, <code>char</code> and <code>std::byte</code> is unspecified, otherwise the value of the element is the value of the object they represent.</p></li>
</ul></li>
<li><p>Allow a pointer to an object representation to be obtained through a <code>reinterpret_cast</code> to <code>unsigned char</code>, <code>char</code> and <code>std::byte</code>.</p></li>
<li><p>Allow a pointer to an object representation to be cast back to a pointer to its respective object via <code>reinterpret_cast</code>.</p></li>
<li><p>Specify that <code>std::launder</code> will prefer to return a pointer to an object that is not an element of an object representation.</p></li>
<li><p>Allow pointer arithmetic to be performed on pointers to elements of an object representation if the type of the expression is <code>unsigned char*</code>, <code>char*</code> or <code>std::byte*</code>.</p></li>
</ul>
<h2 id="examples"><span class="header-section-number">5.1</span> Examples<a href="#examples" class="self-link"></a></h2>
<p>Here is an example demonstrating the difference:</p>
<table>
<thead>
<tr class="header">
<th><div style="text-align:center">
<strong>Before</strong>
</div></th>
<th><div style="text-align:center">
<strong>After</strong>
</div></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><div class="sourceCode" id="cb2"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb2-1"><a href="#cb2-1"></a><span class="kw">using</span> T <span class="op">=</span> <span class="dt">unsigned</span> <span class="dt">char</span><span class="op">*</span>;</span>
<span id="cb2-2"><a href="#cb2-2"></a><span class="dt">int</span> a <span class="op">=</span> <span class="dv">0</span>;</span>
<span id="cb2-3"><a href="#cb2-3"></a>T b <span class="op">=</span> <span class="kw">reinterpret_cast</span><span class="op">&lt;</span>T<span class="op">&gt;(&amp;</span>a<span class="op">)</span>;</span>
<span id="cb2-4"><a href="#cb2-4"></a><span class="co">// Pointer value unchanged, still</span></span>
<span id="cb2-5"><a href="#cb2-5"></a><span class="co">// points to the int object</span></span>
<span id="cb2-6"><a href="#cb2-6"></a>T c <span class="op">=</span> <span class="op">++</span>b;</span>
<span id="cb2-7"><a href="#cb2-7"></a><span class="co">// UB, expression type differs</span></span>
<span id="cb2-8"><a href="#cb2-8"></a><span class="co">// from element type</span></span></code></pre></div></td>
<td><div class="sourceCode" id="cb3"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb3-1"><a href="#cb3-1"></a><span class="kw">using</span> T <span class="op">=</span> <span class="dt">unsigned</span> <span class="dt">char</span><span class="op">*</span>;</span>
<span id="cb3-2"><a href="#cb3-2"></a><span class="dt">int</span> a <span class="op">=</span> <span class="dv">0</span>;</span>
<span id="cb3-3"><a href="#cb3-3"></a>T b <span class="op">=</span> <span class="kw">reinterpret_cast</span><span class="op">&lt;</span>T<span class="op">&gt;(&amp;</span>a<span class="op">)</span>;</span>
<span id="cb3-4"><a href="#cb3-4"></a><span class="co">// Pointer now points to the first unsigned</span></span>
<span id="cb3-5"><a href="#cb3-5"></a><span class="co">// char element of the object representation</span></span>
<span id="cb3-6"><a href="#cb3-6"></a>T c <span class="op">=</span> <span class="op">++</span>b; </span>
<span id="cb3-7"><a href="#cb3-7"></a><span class="co">// This is now a pointer to the second</span></span>
<span id="cb3-8"><a href="#cb3-8"></a><span class="co">// element of the object representation</span></span>
<span id="cb3-9"><a href="#cb3-9"></a><span class="op">++(*</span>c<span class="op">)</span>; <span class="co">// OK</span></span></code></pre></div></td>
</tr>
</tbody>
</table>

<p>Another example for arrays:</p>
<table>
<thead>
<tr class="header">
<th><div style="text-align:center">
<strong>Before</strong>
</div></th>
<th><div style="text-align:center">
<strong>After</strong>
</div></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><div class="sourceCode" id="cb4"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb4-1"><a href="#cb4-1"></a><span class="kw">using</span> T <span class="op">=</span> <span class="dt">unsigned</span> <span class="dt">char</span><span class="op">*</span>;</span>
<span id="cb4-2"><a href="#cb4-2"></a><span class="dt">int</span> a<span class="op">[</span><span class="dv">5</span><span class="op">]{}</span>;</span>
<span id="cb4-3"><a href="#cb4-3"></a>T b <span class="op">=</span> <span class="kw">reinterpret_cast</span><span class="op">&lt;</span>T<span class="op">&gt;(&amp;</span>a<span class="op">)</span>; </span>
<span id="cb4-4"><a href="#cb4-4"></a><span class="co">// Pointer value unchanged, still</span></span>
<span id="cb4-5"><a href="#cb4-5"></a><span class="co">// points to the array object</span></span>
<span id="cb4-6"><a href="#cb4-6"></a><span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">0</span>; i <span class="op">&lt;</span> <span class="kw">sizeof</span><span class="op">(</span><span class="dt">int</span><span class="op">)</span> <span class="op">*</span> <span class="dv">5</span>; <span class="op">++</span>i<span class="op">)</span></span>
<span id="cb4-7"><a href="#cb4-7"></a>  b<span class="op">[</span>i<span class="op">]</span> <span class="op">=</span> <span class="dv">0</span>; <span class="co">// UB, expression type differs</span></span>
<span id="cb4-8"><a href="#cb4-8"></a>            <span class="co">// from element type</span></span></code></pre></div></td>
<td><div class="sourceCode" id="cb5"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb5-1"><a href="#cb5-1"></a><span class="kw">using</span> T <span class="op">=</span> <span class="dt">unsigned</span> <span class="dt">char</span><span class="op">*</span>;</span>
<span id="cb5-2"><a href="#cb5-2"></a><span class="dt">int</span> a<span class="op">[</span><span class="dv">5</span><span class="op">]{}</span>;</span>
<span id="cb5-3"><a href="#cb5-3"></a>T b <span class="op">=</span> <span class="kw">reinterpret_cast</span><span class="op">&lt;</span>T<span class="op">&gt;(&amp;</span>a<span class="op">)</span>; </span>
<span id="cb5-4"><a href="#cb5-4"></a><span class="co">// Pointer now points to the first </span></span>
<span id="cb5-5"><a href="#cb5-5"></a><span class="co">// unsigned char element of the</span></span>
<span id="cb5-6"><a href="#cb5-6"></a><span class="co">// object representation of the array</span></span>
<span id="cb5-7"><a href="#cb5-7"></a><span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">0</span>; i <span class="op">&lt;</span> <span class="kw">sizeof</span><span class="op">(</span><span class="dt">int</span><span class="op">)</span> <span class="op">*</span> <span class="dv">5</span>; <span class="op">++</span>i<span class="op">)</span></span>
<span id="cb5-8"><a href="#cb5-8"></a>  b<span class="op">[</span>i<span class="op">]</span> <span class="op">=</span> <span class="dv">0</span>; <span class="co">// OK</span></span></code></pre></div></td>
</tr>
</tbody>
</table>
<h1 id="design-choices"><span class="header-section-number">6</span> Design Choices<a href="#design-choices" class="self-link"></a></h1>
<h2 id="contiguous-layout-types"><span class="header-section-number">6.1</span> Contiguous-layout types<a href="#contiguous-layout-types" class="self-link"></a></h2>
<p>A major limitation for this proposal is that only objects of trivially-copyable or standard-layout type are guaranteed to occupy contiguous storage. This presents the challenge of not being able to define an object representation as an array for the purpose of pointer arithmetic for many types. This limitation is demonstrated by this example:</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb6-1"><a href="#cb6-1"></a><span class="kw">struct</span> S</span>
<span id="cb6-2"><a href="#cb6-2"></a><span class="op">{</span></span>
<span id="cb6-3"><a href="#cb6-3"></a>  S<span class="op">(</span><span class="kw">const</span> S<span class="op">&amp;</span> value<span class="op">)</span> <span class="op">:</span> a<span class="op">(</span>value<span class="op">.</span>a<span class="op">)</span> <span class="op">{</span> <span class="op">}</span></span>
<span id="cb6-4"><a href="#cb6-4"></a>  <span class="dt">int</span> a;</span>
<span id="cb6-5"><a href="#cb6-5"></a></span>
<span id="cb6-6"><a href="#cb6-6"></a><span class="kw">private</span><span class="op">:</span></span>
<span id="cb6-7"><a href="#cb6-7"></a>  <span class="dt">int</span> b;</span>
<span id="cb6-8"><a href="#cb6-8"></a><span class="op">}</span>;</span></code></pre></div>
<p>This type is not guaranteed to occupy contiguous storage, although in practice it always will. As such, this proposal intends to define a new category for types, contiguous-layout types, which are effectively trivially-copyable types without the requirement for trivial special member functions, as in a reasonable implementation, special member functions would not impact the layout of the class.</p>
<p>With the definition of objects guaranteed to be contiguous less restrictive, the object representation of an object may be defined to be a sequence, that is treated as an array if the type of the object the object representation is associated with is a contiguous-layout type, allowing for pointer arithmetic to be performed on pointers that point to elements of an object representation. This grants a fair bit more latitude for when one wants to access the object representation of an object.</p>
<h2 id="preserving-reinterpret_cast-and-static_cast-equivalence"><span class="header-section-number">6.2</span> Preserving <code>reinterpret_cast</code> and <code>static_cast</code> equivalence<a href="#preserving-reinterpret_cast-and-static_cast-equivalence" class="self-link"></a></h2>
<p>There also exists the question of preserving the current <code>reinterpret_cast</code> and <code>static_cast</code> equivalence for object pointer types. The proposed wording does not do so when <code>reinterpret_cast</code> is used to cast a pointer to <code>unsigned char*</code>, <code>char*</code>, and <code>std::byte*</code> as doing so would present a conflict with resulting in a pointer to the object representation or if it should follow the pointer-interconvertibility rules used by <code>static_cast</code>.</p>

<p>For example:</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb7-1"><a href="#cb7-1"></a><span class="kw">struct</span> S</span>
<span id="cb7-2"><a href="#cb7-2"></a><span class="op">{</span></span>
<span id="cb7-3"><a href="#cb7-3"></a>  <span class="dt">unsigned</span> <span class="dt">char</span> a;</span>
<span id="cb7-4"><a href="#cb7-4"></a><span class="op">}</span>;</span>
<span id="cb7-5"><a href="#cb7-5"></a></span>
<span id="cb7-6"><a href="#cb7-6"></a><span class="dt">void</span> f<span class="op">()</span></span>
<span id="cb7-7"><a href="#cb7-7"></a><span class="op">{</span></span>
<span id="cb7-8"><a href="#cb7-8"></a>  S b<span class="op">{</span><span class="dv">0</span><span class="op">}</span>;</span>
<span id="cb7-9"><a href="#cb7-9"></a>  <span class="dt">unsigned</span> <span class="dt">char</span><span class="op">*</span> c <span class="op">=</span> <span class="kw">reinterpret_cast</span><span class="op">&lt;</span><span class="dt">unsigned</span> <span class="dt">char</span><span class="op">*&gt;(&amp;</span>c<span class="op">)</span>;</span>
<span id="cb7-10"><a href="#cb7-10"></a><span class="op">}</span></span></code></pre></div>
<p>The current approach taken by this proposal is to only allow for <code>reinterpret_cast</code> to convert <code>&amp;b</code> into a pointer that points to an element of the object representation of <code>b</code>. Preserving the equivalence leads to the question of whether the cast should follow the pointer-interconvertibility rules and result in a pointer to <code>b.a</code>, or result in a pointer to the first elelment of the object representation of <code>b</code>. However, not preserving the equivalence will prevent <code>std::memcpy</code> from being implemented by the user with standard C++, as casting from a <code>void*</code> to <code>unsigned char*</code> will not result in a pointer pointing to an element of the object representation. It is unclear which of these it should be and is best to be decided on by CWG.</p>
<h2 id="the-stdlaunder-issue"><span class="header-section-number">6.3</span> The <code>std::launder</code> issue<a href="#the-stdlaunder-issue" class="self-link"></a></h2>
<p>Since multiple objects may occupy the same storage, there exists an issue that elements of these object’s respective object representations will overlap, and will present the issue of having multiple objects that <code>std::launder</code> can return a pointer to. This proposal remedies the issue by prioritizing objects that are not elements of an object representation, and if such an object is not found, then a pointer to an unspecified element of the set of viable objects is returned.</p>
<h2 id="self-representing-objects"><span class="header-section-number">6.4</span> “Self-representing” objects<a href="#self-representing-objects" class="self-link"></a></h2>
<p>Certain objects are suitable to act as their own object representation, such as object of type <code>unsigned char</code>, <code>char</code> and <code>std::byte</code> and arrays of these types. This is to prevent infinite recursion of objects having object representations, as happens with the current word if read pedantically.</p>
<h2 id="value-and-access-of-elements-of-object-representations"><span class="header-section-number">6.5</span> Value and access of elements of object representations<a href="#value-and-access-of-elements-of-object-representations" class="self-link"></a></h2>
<p>“Self-representing” elements of an object representation of non-array type will are specified to have their own value, as expected, and all other elements of an object representation have an unspecified value. The reasoning for this is quite obvious, as it would be extremely difficult to specify what the value of each element would be. Access of the elements is intended to be well defined, and is under the proposed wording, however it is up to CWG whether it should be specified explicitly.</p>
<h1 id="wording"><span class="header-section-number">7</span> Wording<a href="#wording" class="self-link"></a></h1>
<h2 id="memory-and-object-model-intro.object-intro.memory-basic.life"><span class="header-section-number">7.1</span> Memory and object model [intro.object], [intro.memory], [basic.life]<a href="#memory-and-object-model-intro.object-intro.memory-basic.life" class="self-link"></a></h2>
<p>Changes to [intro.memory] p3 sentence 1</p>
<blockquote>
<p><span class="marginalizedparent"><a class="marginalized">3</a></span> A <em>memory location</em> is either an object of scalar type <span class="add" style="color: #006e28"><ins>and any overlapping elements of an object representation,</ins></span>or a maximal sequence of adjacent bit-fields all having nonzero width <span class="add" style="color: #006e28"><ins>and any overlapping elements of an object representation.</ins></span></p>
</blockquote>
<p>Insert a new paragraph below [intro.object] p1</p>
<div class="add" style="color: #006e28">

<blockquote>
<p><span class="marginalizedparent"><a class="marginalized">2</a></span> The <em>object representation</em> of an object <code>a</code> of type <code>cv T</code> is a sequence of <code>N</code> <code>cv unsigned char</code> objects that occupy the same storage as <code>a</code>, where <code>N</code> is equal to <code>sizeof(T)</code>. The sequence is considered to be an array of <code>N</code> <code>T</code> if <code>T</code> is a contiguous-layout type. The object representation of an object of type <code>unsigned char</code>, <code>char</code>, <code>std::byte</code>, or an array of such types (ignoring cv-qualification), is itself. Unless an object representation is of an object of type <code>unsigned char</code>, <code>char</code> or <code>std::byte</code> (ignoring cv-qualification), the value of the elements of the object representation is unspecified. The object representation of an object nested within an object <code>o</code> is guaranteed to appear in the object representation of <code>o</code>.</p>
</blockquote>

</div>
<p>Changes to [intro.object] p8</p>
<blockquote>
<p><span class="marginalizedparent"><a class="marginalized">8</a></span> […] Unless it is a bit-field, an object with nonzero size shall occupy one or more bytes of storage, including every byte that is occupied in full or in part by any of its subobjects. An object of <span class="rm" style="color: #bf0303"><del>trivially copyable or standard-layout</del></span><span class="add" style="color: #006e28"><ins>contiguous-layout</ins></span> type shall occupy contiguous bytes of storage.</p>
</blockquote>
<p>Changes to [intro.object] p9</p>
<blockquote>
<p><span class="marginalizedparent"><a class="marginalized">9</a></span> […] Two objects with overlapping lifetimes that are not bit-fields may have the same address if one is nested within the other, or if at least one is a subobject of zero size and they are of different types<span class="add" style="color: #006e28"><ins>, or if at least one is an element of an object representation</ins></span>; otherwise, they have distinct addresses and occupy disjoint bytes of storage.</p>
</blockquote>
<p>Insert a new paragraph below [basic.life] p2</p>
<div class="add" style="color: #006e28">

<blockquote>
<p><span class="marginalizedparent"><a class="marginalized">3</a></span> The lifetime of the elements of the object representation of an object begins when the lifetime of the object begins and ends when the lifetime of the object ends.</p>
</blockquote>

</div>
<h2 id="contiguous-layout-types-basic.types-class.prop"><span class="header-section-number">7.2</span> Contiguous-layout types [basic.types], [class.prop]<a href="#contiguous-layout-types-basic.types-class.prop" class="self-link"></a></h2>
<p>Remove [basic.types] p4 sentence 1</p>
<div class="rm" style="color: #bf0303">

<blockquote>
<p><span class="marginalizedparent"><a class="marginalized">4</a></span> The <em>object representation</em> of an object of type <code>T</code> is the sequence of <code>N</code> <code>unsigned char</code> objects taken up by the object of type <code>T</code>, where N equals <code>sizeof(T)</code>.</p>
</blockquote>

</div>
<p>Append a sentence to [basic.types] p9</p>
<blockquote>
<p><span class="marginalizedparent"><a class="marginalized">9</a></span> […] Scalar types, standard-layout class types, arrays of such types and cv-qualified versions of these types are collectively called <em>standard-layout types</em>. <span class="add" style="color: #006e28"><ins>Scalar types, contiguous-layout class types, (possibly multi-dimensional) arrays of such types and cv-qualified versions of these types are collectively called <em>contiguous-layout types</em>.</ins></span></p>
</blockquote>
<p>Insert a new paragraph below [class.prop] p7</p>
<div class="add" style="color: #006e28">

<blockquote>
<p><span class="marginalizedparent"><a class="marginalized">8</a></span> A class is a <em>contiguous-layout class</em> if it has no virtual functions, no virtual base classes, no non-static data members of non-contiguous-layout class type (or array of such types), and no base classes of non-contiguous-layout class type.</p>
</blockquote>

</div>
<h2 id="access-to-object-representations-via-reinterpret_cast-expr.reinterpret.cast"><span class="header-section-number">7.3</span> Access to object representations via <code>reinterpret_cast</code> [expr.reinterpret.cast]<a href="#access-to-object-representations-via-reinterpret_cast-expr.reinterpret.cast" class="self-link"></a></h2>
<p>Replace [expr.reinterpret.cast] p7</p>
<div class="rm" style="color: #bf0303">

<blockquote>
<p><span class="marginalizedparent"><a class="marginalized">7</a></span> An object pointer can be explicitly converted to an object pointer of a different type. When a prvalue <code>v</code> of object pointer type is converted to the object pointer type “pointer to <code>cv T</code>”, the result is <code>static_cast&lt;cv T*&gt;(static_­cast&lt;cv void*&gt;(v))</code>.</p>
</blockquote>

</div>
<div class="add" style="color: #006e28">

<blockquote>
<p><span class="marginalizedparent"><a class="marginalized">7</a></span> A prvalue <code>v</code> of object pointer type “pointer to <code>cv1 T1</code>” pointing to an object <code>a</code> can be explicitly converted to an object pointer of a different type “pointer to <code>cv2 T2</code>”, where <code>cv2</code> is the same cv-qualification as, or greater cv-qualification than <code>cv1</code>, the result of which is defined as follows:</p>
</blockquote>
<blockquote>
<ul>
<li><span class="marginalizedparent"><a class="marginalized">(7.1)</a></span> If <code>T1</code> is a contiguous-layout type and <code>T2</code> is <code>unsigned char</code>, <code>char</code> or <code>std::byte</code>, the result is a pointer to the first element of the object representation of <code>a</code>.</li>
</ul>
</blockquote>
<blockquote>
<ul>
<li><span class="marginalizedparent"><a class="marginalized">(7.2)</a></span> Otherwise, if <code>a</code> points to the object representation of an object <code>b</code> of type <code>T2</code> (ignoring cv-qualification), or the first element thereof, the result is a pointer to <code>b</code>.</li>
</ul>
</blockquote>
<blockquote>
<ul>
<li><span class="marginalizedparent"><a class="marginalized">(7.3)</a></span> Otherwise, the result is <code>static_cast&lt;cv2 T2*&gt;(static_cast&lt;cv2 void*&gt;(v))</code>.</li>
</ul>
</blockquote>

</div>
<h2 id="pointer-arithmetic-expr.add"><span class="header-section-number">7.4</span> Pointer arithmetic [expr.add]<a href="#pointer-arithmetic-expr.add" class="self-link"></a></h2>
<p>Replace [expr.add] p6</p>
<div class="rm" style="color: #bf0303">

<blockquote>
<p><span class="marginalizedparent"><a class="marginalized">6</a></span> For addition or subtraction, if the expressions <code>P</code> or <code>Q</code> have type “pointer to <code>cv T</code>”, where <code>T</code> and the array element type are not similar, the behavior is undefined.</p>
</blockquote>

</div>
<div class="add" style="color: #006e28">

<blockquote>
<p><span class="marginalizedparent"><a class="marginalized">6</a></span> For addtion and subtraction where <code>P</code> or <code>Q</code> have type “pointer to <code>cv T</code>” and point to an object <code>o</code>, one of the following must hold true:</p>
</blockquote>
<blockquote>
<ul>
<li><span class="marginalizedparent"><a class="marginalized">(6.1)</a></span> <code>T</code> is similar to the type of the <code>o</code>, or</li>
<li><span class="marginalizedparent"><a class="marginalized">(6.2)</a></span> <code>T</code> is similar to <code>unsigned char</code>, <code>char</code> or <code>std::byte</code> and <code>o</code> is an element of an object representation.</li>
</ul>
</blockquote>
<blockquote>
<p>Otherwise, the behavior is undefined.</p>
</blockquote>

</div>
<h2 id="stdlaunder-ptr.launder"><span class="header-section-number">7.5</span> <code>std::launder</code> [ptr.launder]<a href="#stdlaunder-ptr.launder" class="self-link"></a></h2>
<p>Changes to [ptr.launder] p3</p>
<p><em>Returns:</em> A value of type <code>T*</code> that points to <code>X</code>. <span class="add" style="color: #006e28"><ins>If multiple such objects exist, the result is the object in the set of possible objects that is not an element of an object representation. Otherwise, it is implementation-defined which object in the set the result points to.</ins></span></p>
<h1 id="acknowledgements"><span class="header-section-number">8</span> Acknowledgements<a href="#acknowledgements" class="self-link"></a></h1>
<p>Thank you to Jason Cobb, John Iacino, Marcell Kiss, and Killian Long, and everyone who participated on the std-proposals mailing list for the countless reviews and suggestions. Addtionally, I would like to thank Professor Ben Woodard for his grammatical review.</p>
<h1 id="references"><span class="header-section-number">9</span> References<a href="#references" class="self-link"></a></h1>

<div id="refs" role="doc-bibliography">
<div id="ref-CWG1314">
<p>[CWG1314] Nikolay Ivchenkov. 2011. Pointer arithmetic within standard-layout objects. <br />
<a href="https://wg21.link/cwg1314">https://wg21.link/cwg1314</a></p>
</div>
<div id="ref-P0137R1">
<p>[P0137R1] Richard Smith. 2016. Core Issue 1776: Replacement of class objects containing reference members. <br />
<a href="https://wg21.link/p0137r1">https://wg21.link/p0137r1</a></p>
</div>
</div>
</div>
</div>
</body>
</html>
